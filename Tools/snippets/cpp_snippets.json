{
	/**
		#INDEX
		======
		## General
		1. new file
		2. debug tools
		3. io tools
		
		## Algorithm
		1. basic
		2. trees
		3. string
		4. other data structures
		5. math
		6. graph
		7. flow
	*/


	  //==============================//
	 //===========new file===========//
	//==============================//

	"new file": {
		"prefix": "#new",
		"body": [
			"#include <vector>",
			"#include <iostream>",
			"#include <algorithm>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"using LL=long long;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}",
		],
		"description": "C++ 头文件和默认参数",
	},

	"new file multi-testcase": {
		"prefix": "#newt",
		"body": [
			"#include <vector>",
			"#include <iostream>",
			"#include <algorithm>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"using LL=long long;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    int t;",
			"    cin>>t;",
			"    while(t--) solve();",
			"    return 0;",
			"}",
		],
		"description": "C++ 头文件和默认参数,多组数据",
	},	

	"DataGen": {
		"prefix": "#datagen",
		"body": [
			"#include<iostream>",
			"#include<fstream>",
			"#include<testlib.h>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"typedef long long LL;",
			"",
			"int main(int argc, char *argv[]) {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    registerGen(argc, argv, 1);",
			"    $0",
			"}",
		],
		"description": "Data Generator",
	},
	
	  //==============================//
	 //=========debug tools==========//
	//==============================//

	"debug": {
		"prefix": "#debug",
		"body": [
			"// #define ONLINE_JUDGE",
			"#ifndef ONLINE_JUDGE",
			"#include<heltim7/debug>",
			"#else",
			"#define debug(...)",
			"#endif",
		],
		"description": "C++ fast debuger",
	},

	  //==============================//
     //==========io tools============//
    //==============================//

	"Fast Input": {
		"prefix": "#io",
		"body": [
			"namespace io {",
			"    const int MAXBUF = 1e6;",
			"    char buf[MAXBUF], *pl, *pr;",
			"",
			"    #define gc() \\",
			"    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
			"    ? EOF : *pl++)",
			"",
			"    template<typename T> T rd(T &x) {",
			"        x = 0;",
			"        T f = 1;",
			"        char c = gc();",
			"        while (!isdigit(c)) {",
			"            if (c == '-') f = -1;",
			"            c = gc();",
			"        }",
			"        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
			"        return x = x * f;",
			"    }",
			"",
			"    template<typename... T> void reads_impl(T&... x) { (rd(x),...); }",
			"",
			"    #define read(x) io::rd(x)",
			"    #define reads(...) io::reads_impl(__VA_ARGS__)",
			"}",
		],
		"description": "精简版快读",
	},	

	"Fast IO": {
		"prefix": "#ioFull",
		"body": [
			"namespace io {",
			"    const int MAXBUF = 1e6, MAXLEN = 1e6;",
			"    char buf[MAXBUF], *pl, *pr;",
			"    char str[MAXLEN];",
			"",
			"    #define gc() \\",
			"    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
			"    ? EOF : *pl++)",
			"",
			"    template<typename T> T rd(T &x) {",
			"        x = 0;",
			"        T f = 1;",
			"        char c = gc();",
			"        while (!isdigit(c)) {",
			"            if (c == '-') f = -1;",
			"            c = gc();",
			"        }",
			"        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
			"        if (c != '.') return x = x * f;",
			"        for (double t = 0.1; c = gc(), isdigit(c); t *= 0.1) x += (c - '0') * t;",
			"        return x = x * f;",
			"    }",
			"",
			"    char* rd(char *p = str) {",
			"        char c = gc(), *h = p;",
			"        while (!isgraph(c)) c = gc();",
			"        while (isgraph(c)) *p++ = c, c = gc();",
			"        *p = '\\0';",
			"        return h;",
			"    }",
			"",
			"    char rd(char &c) {",
			"        c = gc();",
			"        while (!isgraph(c)) c = gc();",
			"        return c;",
			"    }",
			"",
			"    string rd(string &s) { return s = rd(str); }",
			"",
			"    template<typename... T> void reads_impl(T&... x) { (rd(x),...); }",
			"",
			"    #define read(x) io::rd(x)",
			"    #define reads(...) io::reads_impl(__VA_ARGS__)",
			"",
			"    const int MAXPBUF = 1e6, PRECISION = 7;",
			"    char pbuf[MAXPBUF], *pp = pbuf;",
			"",
			"    void clear_buffer() { fwrite(pbuf, 1, pp-pbuf, stdout), pp = pbuf; }",
			"",
			"    void push(const char &c) {",
			"        if (pp - pbuf == MAXPBUF) clear_buffer();",
			"        *pp++ = c;",
			"    }",
			"",
			"    template<typename T> void wt(T x) {",
			"        if (x < 0) push('-'), x = -x;",
			"        static int sta[40];",
			"        int top = 0;",
			"        do {",
			"            sta[top++] = x % 10;",
			"        } while (x/=10);",
			"        while (top) push(sta[--top] + '0');",
			"    }",
			"",
			"    template<typename T> void wt_f(T x,int p) {",
			"        if (x < 0) push('-'), x = -x;",
			"        long long pre = (long long)x;",
			"        wt(pre);",
			"        x -= pre;",
			"        if (p) push('.');",
			"        while (p--) {",
			"            x *= 10;",
			"            int t = (int)x;",
			"            x -= t;",
			"            push(t + '0');",
			"        }",
			"    }",
			"",
			"    void wt(const char &c) { push(c); }",
			"    void wt(const string &s) { for (auto &x:s) push(x); }",
			"    void wt(const char *p) { while (*p != '\\0') push(*p++); }",
			"",
			"    void wt(const float &x, int p = PRECISION) { wt_f(x,p); }",
			"    void wt(const double &x, int p = PRECISION) { wt_f(x,p); }",
			"    void wt(const long double &x, int p = PRECISION) { wt_f(x,p); }",
			"",
			"    template<typename... T> void writes_impl(const T&... x) { (wt(x),...); }",
			"",
			"    #define write(...) io::wt(__VA_ARGS__)",
			"    #define writes(...) io::writes_impl(__VA_ARGS__)",
			"",
			"    struct Exit {",
			"        ~Exit() { clear_buffer(); }",
			"    } static exit;",
			"}",
		],
		"description": [
			"基于fread和fwrite的快读快写",
			"",
			"## Usage:",
			"1. read(x);                 读入一个变量",
			"2. write(x);                输出一个变量",
			"3. write(x,y);              输出精度为y的浮点数x,精度默认值为PRECISION",
			"4. reads(...); writes(...); 多参数读写,不支持精度控制且无返回值",
			"5. io::clear_buffer();      手动清空输出缓冲",
			"",
			"## Features:",
			"1. 支持 int,long long,int128,float,double,long double,char(array),string",
			"2. 退出程序会自动清空输出缓冲",
			"",
			"## Parameters:",
			"1. MAXBUF/MAXPBUF 读入/输出缓存大小,数值越大越占内存,fread/fwrite执行的操作越少",
			"                  BUF的大小不影响功能,通常保持不变即可,预设大小的缓存数组会占用3-4M内存",
			"2. MAXLEN         单个字符串长度,字符串的最大连续长度,如果超出则会发生数组越界",
			"3. PRECISION      默认精度",
			"",
			"## Note:",
			"1. 不需要using namespace io,已经define了read和write",
			"2. 不要关闭同步流(std::ios::sync_with_stdio(true);)",
			"3. 如果使用了read,那么不能再使用其他输入函数例如scanf和cin,会导致io顺序错误",
			"   write同理,这是由快读快写的缓冲机制决定的,除非事先清空缓冲",
			"4. 浮点数输出不会执行四舍五入,并且可能输出-0"
		]
	},
	
	  //==============================//
	 //=======algorithm:basic========//
	//==============================//

	"lowbit": {
		"prefix": "#lowbit",
		"body": [
			"#define lowbit(x) (x&(-x))",
		],
		"description": "get the lowest bit of x",
	},

	"quick power": {
		"prefix": "#qpow",
		"body": [
			"LL qpow(LL a,LL b) {",
			"    LL res=1;",
			"    while(b) {",
			"        if(b&1) res=res*a${1:%mod};",
			"        b>>=1;",
			"        a=a*a${1:%mod};",
			"    }",
			"    return res;",
			"}",
		],
		"description": "quick power O(logn)",
	},	

	"discrete (binary search)": {
		"prefix": "#discrete_bs",
		"body": [
			"sort(${1:num}.begin(),${1:num}.end());",
			"${1:num}.erase(unique(${1:num}.begin(),${1:num}.end()),${1:num}.end());",
			"for(int i=1;i<=n;i++) ",
			"    ${2:arr}[i]=lower_bound(${1:num}.begin(),${1:num}.end(),${2:arr}[i])-${1:num}.begin()+1;",
			"",
		],
		"description": "离散化 (排序+二分) O(nlogn)",
	},	

	  //==============================//
	 //=======algorithm:trees========//
	//==============================//

	"FenwickTree": {
		"prefix": "#fenwick",
		"body": [
			"template<typename T> ",
			"struct Fenwick {",
			"    std::vector<T> tr;",
			"    int sz=0;",
			"",
			"    int lowbit(int x) { return x&(-x); }",
			"",
			"    void update(T &aim,T &val) {",
			"        aim+=val;",
			"    }",
			"",
			"    void add(int pos,T val) {",
			"        while(pos<=sz) update(tr[pos],val),pos+=lowbit(pos);",
			"    }",
			"",
			"    T query(int pos) {",
			"        T res=0;",
			"        while(pos) update(res,tr[pos]),pos-=lowbit(pos);",
			"        return res;",
			"    }",
			"",
			"    Fenwick(int n) { tr.resize(sz=n+1); }",
			"};",
		],
		"description": "FenwickTree",
	},
	

	"heavy path decomposition": {
		"prefix": "#heavy-path-decomposition",
		"body": [
			"const int N=${1:1e5+10},M=N*2;",
			"int h[N],w[N],e[M],ne[M],idx;",
			"int id[N],nw[N],cnt;",
			"int dep[N],sz[N],top[N],p[N],hch[N];",
			"struct NODE{",
			"    int l,r;",
			"    ${2:LL add,sum;}",
			"} tr[N*4];",
			"",
			"void add(int a,int b){",
			"    e[idx]=b,ne[idx]=h[a],h[a]=idx++;",
			"    e[idx]=a,ne[idx]=h[b],h[b]=idx++;",
			"}",
			"",
			"void modify(int x,int l,int r,int v){",
			"    ",
			"}",
			"",
			"${3:LL} query(int x,int l,int r){",
			"    ",
			"}",
			"",
			"void dfs1(int x,int fa,int d){",
			"    dep[x]=d,p[x]=fa,sz[x]=1;",
			"    for(int i=h[x];~i;i=ne[i]){",
			"        int j=e[i];",
			"        if(j==fa) continue;",
			"        dfs1(j,x,d+1);",
			"        sz[x]+=sz[j];",
			"        if(sz[hch[x]]<sz[j]) hch[x]=j;",
			"    }",
			"}",
			"",
			"void dfs2(int x,int t){",
			"    id[x]=++cnt,nw[cnt]=w[x],top[x]=t;",
			"    if(!hch[x]) return;",
			"    dfs2(hch[x],t);",
			"    for(int i=h[x];~i;i=ne[i]){",
			"        int j=e[i];",
			"        if(j==p[x]||j==hch[x]) continue;",
			"        dfs2(j,j);",
			"    }",
			"}",
			"",
			"void modify_path(int x,int y,int k){",
			"    while(top[x]!=top[y]){",
			"        if(dep[top[x]]<dep[top[y]]) swap(x,y);",
			"        modify(1,id[top[x]],id[x],k);",
			"        x=p[top[x]];",
			"    }",
			"    if(dep[x]<dep[y]) swap(x,y);",
			"    modify(1,id[y],id[x],k);",
			"}",
			"",
			"${3:LL} query_path(int x,int y){",
			"    ${3:LL} res=0;",
			"    while(top[x]!=top[y]){",
			"        if(dep[top[x]]<dep[top[y]]) swap(x,y);",
			"        res+=query(1,id[top[x]],id[x]);",
			"        x=p[top[x]];",
			"    }",
			"    if(dep[x]<dep[y]) swap(x,y);",
			"    res+=query(1,id[y],id[x]);",
			"    return res;",
			"}",
			"",
			"void modify_tree(int x,int k){",
			"    modify(1,id[x],id[x]+sz[x]-1,k);",
			"}",
			"",
			"${3:LL} query_tree(int x){",
			"    return query(1,id[x],id[x]+sz[x]-1);",
			"}",
		],
		"description": [
			"将树上路径转化为不超过logn级别数量的线段 预处理复杂度 O(n) ",
			"需要初始化为0的变量: idx,cnt,h[],hch[]",
			"预处理: dfs1(1,-1,1); dfs2(1,1);"
		],
	},

	"Treap": {
		"prefix": "#treap",
		"body": [
			"const int N=1e5+10,INF=0x3f3f3f3f;",
			"",
			"struct NODE{",
			"    int l,r;",
			"    int key,val;",
			"    int cnt,size;",
			"}tr[N];",
			"int root,idx;",
			"",
			"int new_node(int key){",
			"    tr[++idx].key=key;",
			"    tr[idx].val=rand();",
			"    tr[idx].cnt=tr[idx].size=1;",
			"    return idx;",
			"}",
			"",
			"void pushup(int id){",
			"    tr[id].size=tr[tr[id].l].size+tr[tr[id].r].size+tr[id].cnt;",
			"}",
			"",
			"void zag(int &p){",
			"    int q=tr[p].r;",
			"    tr[p].r=tr[q].l,tr[q].l=p;",
			"    pushup(p),pushup(q);",
			"    p=q;",
			"}",
			"",
			"void zig(int &p){",
			"    int q=tr[p].l;",
			"    tr[p].l=tr[q].r,tr[q].r=p;",
			"    pushup(p),pushup(q);",
			"    p=q;",
			"}",
			"",
			"void insert(int &p,int key){",
			"    if(!p) p=new_node(key);",
			"    else if(tr[p].key==key) tr[p].cnt++;",
			"    else if(key<tr[p].key) {",
			"        insert(tr[p].l,key);",
			"        if(tr[tr[p].l].val>tr[p].val) zig(p);",
			"    }",
			"    else {",
			"        insert(tr[p].r,key);",
			"        if(tr[tr[p].r].val>tr[p].val) zag(p);",
			"    }",
			"    pushup(p);",
			"}",
			"",
			"void erase(int &p,int key){",
			"    if(!p) return;",
			"    if(tr[p].key==key){",
			"        if(tr[p].cnt>1) tr[p].cnt--;",
			"        else if(!tr[p].l&&!tr[p].r) p=0;",
			"        else if(!tr[p].l||tr[tr[p].r].val>tr[tr[p].l].val)",
			"            zag(p),erase(tr[p].l,key);",
			"        else zig(p),erase(tr[p].r,key);",
			"    }",
			"    else if(key<tr[p].key) erase(tr[p].l,key);",
			"    else erase(tr[p].r,key);",
			"    pushup(p);",
			"}",
			"",
			"int get_rank(int p,int key){",
			"    if(!p) return INF;",
			"    if(tr[p].key==key) return tr[tr[p].l].size+1;",
			"    else if(key<tr[p].key) return get_rank(tr[p].l,key);",
			"    return tr[tr[p].l].size+tr[p].cnt+get_rank(tr[p].r,key);",
			"}",
			"",
			"int get_key(int p,int rank){",
			"    if(!p) return INF;",
			"    int lrank=tr[tr[p].l].size;",
			"    if(rank<=lrank) return get_key(tr[p].l,rank);",
			"    else if(rank<=lrank+tr[p].cnt) return tr[p].key;",
			"    return get_key(tr[p].r,rank-lrank-tr[p].cnt);",
			"}",
			"",
			"int get_prev(int p,int key){",
			"    if(!p) return -INF;",
			"    if(tr[p].key>=key) return get_prev(tr[p].l,key);",
			"    return max(tr[p].key,get_prev(tr[p].r,key));",
			"}",
			"",
			"int get_next(int p,int key){",
			"    if(!p) return INF;",
			"    if(tr[p].key<=key) return get_next(tr[p].r,key);",
			"    return min(tr[p].key,get_next(tr[p].l,key));",
			"}",
			"",
			"void build(){",
			"    root=new_node(-INF);",
			"    tr[root].r=new_node(INF);",
			"    pushup(root);",
			"    if(tr[1].val<tr[2].val) zag(root);",
			"}",
		],
		"description": "Treap",
	},
	
	"Chtholly Tree": {
		"prefix": "#ODT",
		"body": [
			"struct NODE {",
			"    int l,r,v;",
			"    NODE(int L,int R,int V) : l(L),r(R),v(V) {}",
			"    bool operator< (const NODE &x) const{",
			"        return l<x.l;",
			"    }",
			"};",
			"",
			"struct ODT {",
			"    set<NODE> st;",
			"    auto split(int pos){",
			"        auto it=st.lower_bound(NODE(pos,pos,0));",
			"        if(it!=st.end()&&it->l==pos) return it;",
			"        it=prev(it);",
			"        auto [l,r,v]=*it;",
			"        st.erase(it);",
			"        st.insert(NODE(l,pos-1,v));",
			"        return st.insert(NODE(pos,r,v)).first;",
			"    }",
			"",
			"    void assign(int l,int r,int v){",
			"        auto end=split(r+1),begin=split(l);",
			"        st.erase(begin,end);",
			"        st.insert(NODE(l,r,v));",
			"    }",
			"};",
		],
		"description": "Chtholly Tree",
	},

	  //==============================//
	 //=======algorithm:string=======//
	//==============================//

	"ACAM": {
		"prefix": "#acam",
		"body": [
			"struct ACAM {",
			"    const static int A=26;",
			"    const static char start='a';",
			"    struct Node {",
			"        int cnt,next;",
			"        int ch[A];",
			"    };",
			"",
			"    vector<Node> tr;",
			"    int idx=0;",
			"",
			"    int insert(string &s) {",
			"        int root=0;",
			"        for(auto x:s) {",
			"            int c=x-start;",
			"            if(!tr[root].ch[c]) ",
			"                tr[root].ch[c]=new_node();",
			"            root=tr[root].ch[c];",
			"        }",
			"        tr[root].cnt++;",
			"        return root;",
			"    }",
			"",
			"    void build() {",
			"        queue<int> q;",
			"        for(int i=0;i<A;i++) ",
			"            if(tr[0].ch[i]) {",
			"                q.push(tr[0].ch[i]);",
			"                //...",
			"            }",
			"        while(q.size()) {",
			"            auto root=q.front();",
			"            q.pop();",
			"            for(int i=0;i<A;i++) {",
			"                int &cur=tr[root].ch[i];",
			"                int pre=tr[tr[root].next].ch[i];",
			"                if(!cur) cur=pre;",
			"                else {",
			"                    tr[cur].next=pre;",
			"                    // tr[cur].cnt+=tr[pre].cnt;",
			"                    q.push(cur);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int match() {",
			"        int res=0;",
			"        //...",
			"        return res;",
			"    }",
			"",
			"    int size() { return tr.size(); }",
			"    int new_node() { tr.push_back({});return ++idx; }",
			"    void clear() { tr.clear();tr.resize(1);idx=0; }",
			"    ",
			"    ACAM() { tr.resize(1); }",
			"    ACAM(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
			"} acam;",
		],
		"description": "Aho-Corasick Automaton",
	},	

	"ACAM with fail tree": {
		"prefix": "#acam_fail",
		"body": [
			"struct ACAM {",
			"    const static int A=26;",
			"    const static char start='a';",
			"    struct Node {",
			"        int cnt,next;",
			"        int ch[A];",
			"        vector<int> adj;",
			"    };",
			"",
			"    vector<Node> tr;",
			"    vector<int> label,label_end;",
			"    int idx=0,label_idx=0;",
			"",
			"    int insert(string &s) {",
			"        int root=0;",
			"        for(auto x:s) {",
			"            int c=x-start;",
			"            if(!tr[root].ch[c]) ",
			"                tr[root].ch[c]=new_node();",
			"            root=tr[root].ch[c];",
			"        }",
			"        tr[root].cnt++;",
			"        return root;",
			"    }",
			"",
			"    void build() {",
			"        queue<int> q;",
			"        for(int i=0;i<A;i++) ",
			"            if(tr[0].ch[i]) {",
			"                q.push(tr[0].ch[i]);",
			"                tr[0].adj.push_back(tr[0].ch[i]);",
			"                //...",
			"            }",
			"        while(q.size()) {",
			"            auto root=q.front();",
			"            q.pop();",
			"            for(int i=0;i<A;i++) {",
			"                int &cur=tr[root].ch[i];",
			"                int pre=tr[tr[root].next].ch[i];",
			"                if(!cur) cur=pre;",
			"                else {",
			"                    tr[cur].next=pre;",
			"                    // tr[cur].cnt+=tr[pre].cnt;",
			"                    tr[pre].adj.push_back(cur);",
			"                    q.push(cur);",
			"                }",
			"            }",
			"        }",
			"",
			"        label.resize(size());",
			"        label_end.resize(size());",
			"        relabel(0);",
			"    }",
			"",
			"    void relabel(int u) {",
			"        label[u]=label_end[u]=++label_idx;",
			"        for(int v:tr[u].adj) {",
			"            relabel(v);",
			"            label_end[u]=max(label_end[u],label_end[v]);",
			"        }",
			"    }",
			"    ",
			"    int match() {",
			"        int res=0;",
			"        //...",
			"        return res;",
			"    }",
			"",
			"    int size() { return tr.size(); }",
			"    int new_node() { tr.push_back({});return ++idx; }",
			"    void clear() { tr.clear();tr.resize(1);idx=label_idx=0; }",
			"",
			"    ACAM() { tr.resize(1); }",
			"    ACAM(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
			"} acam;",
		],
		"description": "Aho-Corasick Automaton with fail tree",
	},

	"Suffix Array": {
		"prefix": "#sa",
		"body": [
			"const int N=1e6+10;",
			"int n,m;",
			"int sa[N],fk[N],sk[N],cnt[N],rk[N],ht[N];",
			"string s;",
			"",
			"void get_sa() {",
			"    for(int i=1;i<=n;i++) cnt[fk[i]=s[i]]++;",
			"    for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
			"    for(int i=1;i<=n;i++) sa[cnt[fk[i]]--]=i;",
			"",
			"    for(int k=1;k<n;k<<=1) {",
			"        int num=0;",
			"        for(int i=n-k+1;i<=n;i++) sk[++num]=i;",
			"        for(int i=1;i<=n;i++) if(sa[i]>k) sk[++num]=sa[i]-k;",
			"        for(int i=1;i<=m;i++) cnt[i]=0;",
			"        for(int i=1;i<=n;i++) cnt[fk[i]]++;",
			"        for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
			"        for(int i=n;i;i--) sa[cnt[fk[sk[i]]]--]=sk[i],sk[i]=0;",
			"        swap(fk,sk);",
			"        fk[sa[1]]=num=1;",
			"        for(int i=2;i<=n;i++) fk[sa[i]]=",
			"            (sk[sa[i]]==sk[sa[i-1]]&&sk[sa[i]+k]==sk[sa[i-1]+k])",
			"            ?num:++num;",
			"        if(num==n) break;",
			"        m=num;",
			"    }",
			"}",
			"",
			"void get_ht() {",
			"    for(int i=1;i<=n;i++) rk[sa[i]]=i;",
			"    for(int i=1,k=0;i<=n;i++) {",
			"        if(rk[i]==1) continue;",
			"        if(k) k--;",
			"        int j=sa[rk[i]-1];",
			"        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;",
			"        ht[rk[i]]=k;",
			"    }",
			"}",
		],
		"description": "倍增法求后缀数组 O(nlogn)",
	},

	  //==============================//
	 //=======algorithm:math=========//
	//==============================//

	"combinatorial number": {
		"prefix": "#cmb",
		"body": [
			"const int N=${1:1e5+10};",
			"LL faet[N],infaet[N];",
			"",
			"LL qpow(LL a,LL b){",
			"    LL  res=1;",
			"    while(b){",
			"        if(b&1) res=res*a%mod;",
			"        b>>=1;",
			"        a=a*a%mod;",
			"    }",
			"    return res;",
			"}",
			"",
			"void init(){",
			"    faet[1]=1,faet[0]=1;",
			"    infaet[1]=1,infaet[0]=1;",
			"    for(int i=2;i<N;i++){",
			"        faet[i]=faet[i-1]*i%mod;",
			"        infaet[i]=infaet[i-1]*qpow(i,mod-2)%mod;",
			"    }",
			"}",
			"",
			"LL get(int a,int b){",
			"    return faet[a]*infaet[a-b]%mod*infaet[b]%mod;",
			"}",
		],
		"description": "递推求组合数 O(n)",
	},

	"Prime factorization": {
		"prefix": "#prime_factorization",
		"body": [
			"const int M=1e5+10;",
			"bool st[M];",
			"int primes[M],minp[M],idx;",
			"",
			"void init(int n) {",
			"    st[1]=minp[1]=1;",
			"    for(int i=2;i<=n;i++) {",
			"        if(!st[i]) primes[idx++]=i,minp[i]=i;",
			"        for(int j=0;primes[j]<=n/i;j++) {",
			"            st[primes[j]*i]=true;",
			"            minp[primes[j]*i]=primes[j];",
			"            if(i%primes[j]==0) break;",
			"        }",
			"    }",
			"}",
			"",
			"void get(int val,map<int,int> &mp) {",
			"    while(val>1) {",
			"        int t=minp[val];",
			"        auto it=mp.emplace(t,1).first;",
			"        val/=t;",
			"        while(val%t==0) {",
			"            it->second++;",
			"            val/=t;",
			"        }",
			"    }",
			"}",
		],
		"description": "质因数分解 O(nlogn)",
	},	

	  //==============================//
	 //=======algorithm:graph========//
	//==============================//

	"LCA": {
		"prefix": "#lca",
		"body": [
			"const int N=1e5+10,M=15;",
			"vector<int> adj[N];",
			"int fa[N][M+1],dep[N];",
			"",
			"void getlca(int u,int p){",
			"    for(auto s:adj[u]){",
			"        if(s==p) continue;",
			"        dep[s]=dep[u]+1;",
			"        fa[s][0]=u;",
			"        for(int i=1;i<=M;i++)",
			"            fa[s][i]=fa[fa[s][i-1]][i-1];",
			"        getlca(s,u);",
			"    }",
			"}",
			"",
			"int lca(int a,int b){",
			"    if(dep[a]<dep[b]) swap(a,b);",
			"    for(int k=M;~k;k--)",
			"        if(dep[fa[a][k]]>=dep[b])",
			"            a=fa[a][k];",
			"    if(a==b) return a;",
			"    for(int k=M;~k;k--)",
			"        if(fa[a][k]!=fa[b][k])",
			"            a=fa[a][k],b=fa[b][k];",
			"    return fa[a][0];",
			"}",
		],
		"description": [
			"倍增求LCA O(nlogn)",
			"需要的头文件: <vector>",
			"",
			"变量: N=点数 | M=位数",
			"初始化: dep[root]=1;"
		],
	},

	  //==============================//
	 //=======algorithm:flow=========//
	//==============================//

	"maximum flow": {
		"prefix": "#dinic",
		"body": [
			"const int N=${1:1e4+10},M=${2:1e5+10},INF=0x3f3f3f3f;",
			"int e[M],ne[M],f[M],idx;",
			"int h[N],q[N],arc[N],d[N];",
			"int n,m,S,T;",
			"",
			"void add(int a,int b,int c){",
			"    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;",
			"    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;",
			"}",
			"",
			"int dfs(int id,int lim){",
			"    if(id==T) return lim;",
			"    int flow=0;",
			"    for(int i=arc[id];~i&&flow<lim;i=ne[i]){",
			"        int ver=e[i];",
			"        arc[id]=i;",
			"        if(f[i]&&d[ver]==d[id]+1){",
			"            int t=dfs(ver,min(f[i],lim-flow));",
			"            if(!t) d[ver]=-1;",
			"            f[i]-=t,f[i^1]+=t,flow+=t;",
			"        }",
			"    }",
			"    return flow;",
			"}",
			"",
			"bool bfs(){",
			"    memset(d,-1,sizeof d);",
			"    q[0]=S,arc[S]=h[S],d[S]=0;",
			"    int hh=0,tt=1;",
			"    while(hh<tt){",
			"        int ver=q[hh++];",
			"        for(int i=h[ver];~i;i=ne[i]){",
			"            int t=e[i];",
			"            if(f[i]&&d[t]==-1){",
			"                d[t]=d[ver]+1;",
			"                arc[t]=h[t];",
			"                if(t==T) return 1;",
			"                q[tt++]=t;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			"int dinic(){",
			"    int F=0,flow=0;",
			"    while(bfs()) while(flow=dfs(S,INF)) F+=flow;",
			"    return F;",
			"}",
		],
		"description": "Dinic maxflow",
	},

	"minimum cost maximum flow": {
		"prefix": "#mcmf",
		"body": [
			"const int N=${1:1e4+10},M=${2:1e5+10},INF=0x3f3f3f3f;",
			"int ne[M],e[M],f[M],w[M],idx;",
			"int h[N],q[N],d[N],pre[N],mf[N];",
			"int n,m,S,T;",
			"bool inq[N];",
			"",
			"void add(int a,int b,int c,int d){",
			"    e[idx]=b,f[idx]=c,w[idx]=d,ne[idx]=h[a],h[a]=idx++;",
			"    e[idx]=a,f[idx]=0,w[idx]=-d,ne[idx]=h[b],h[b]=idx++;",
			"}",
			"",
			"bool spfa(){",
			"    memset(d,0x3f,sizeof d);",
			"    memset(mf,0,sizeof mf);",
			"    int hh=0,tt=1;",
			"    q[0]=S,d[S]=0,mf[S]=INF;",
			"    while(hh!=tt){",
			"        int ver=q[hh++];",
			"        if(hh==N) hh=0;",
			"        inq[ver]=0;",
			"",
			"        for(int i=h[ver];~i;i=ne[i]){",
			"            int t=e[i];",
			"            if(f[i]&&d[t]>d[ver]+w[i]){",
			"                d[t]=d[ver]+w[i];",
			"                pre[t]=i;",
			"                mf[t]=min(mf[ver],f[i]);",
			"                if(!inq[t]){",
			"                    q[tt++]=t;",
			"                    if(tt==N) tt=0;",
			"                    inq[t]=1;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return mf[T]>0;",
			"}",
			"",
			"void EK(int &flow,int &cost){",
			"    flow=cost=0;",
			"    while(spfa()){",
			"        flow+=mf[T],cost+=mf[T]*d[T];",
			"        for(int i=T;i!=S;i=e[pre[i]^1]){",
			"            f[pre[i]]-=mf[T];",
			"            f[pre[i]^1]+=mf[T];",
			"        }",
			"    }",
			"}",
		],
		"description": "EK minimum cost maximum flow",
	},

}