{
	/**
		#INDEX
		======
		## General
		1. new file
		2. debug tools
		3. io tools
		4. modint
		5. misc
		
		## Algorithm
		1. basic & misc
		2. trees
		3. string
		4. other data structures
		5. math
		6. graph
		7. flow
		8. dp
	*/


	  //==============================//
	 //===========new file===========//
	//==============================//

	"new file": {
		"prefix": "#new",
		"body": [
			"#include <vector>",
			"#include <iostream>",
			"#include <algorithm>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"using LL=long long;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}",
		],
		"description": "C++ 头文件和默认参数",
	},

	"new file multi-testcase": {
		"prefix": "#newt",
		"body": [
			"#include <vector>",
			"#include <iostream>",
			"#include <algorithm>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"using LL=long long;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    int t;",
			"    cin>>t;",
			"    while(t--) solve();",
			"    return 0;",
			"}",
		],
		"description": "C++ 头文件和默认参数,多组数据",
	},	

	"DataGen": {
		"prefix": "#datagen",
		"body": [
			"#include <iostream>",
			"#include <fstream>",
			"#include <testlib.h>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"typedef long long LL;",
			"",
			"int main(int argc, char *argv[]) {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(nullptr);",
			"    registerGen(argc, argv, 1);",
			"    $0",
			"}",
		],
		"description": "Data Generator",
	},
	
	  //==============================//
	 //=========debug tools==========//
	//==============================//

	"debug": {
		"prefix": "#debug",
		"body": [
			"// #define ONLINE_JUDGE",
			"#ifndef ONLINE_JUDGE",
			"#include <heltim7/debug>",
			"#else",
			"#define debug(...) 7",
			"#endif",
		],
		"description": "C++ fast debuger",
	},

	  //==============================//
     //==========io tools============//
    //==============================//

	"Fast input": {
		"prefix": "#fast_input",
		"body": [
			"namespace fast_io {",
			"    const int MAXBUF = 1e6;",
			"    char buf[MAXBUF], *pl, *pr;",
			"",
			"    #define gc() \\",
			"    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
			"    ? EOF : *pl++)",
			"",
			"    template<typename T> T rd(T &x) {",
			"        x = 0;",
			"        T f = 1;",
			"        char c = gc();",
			"        while (!isdigit(c)) {",
			"            if (c == '-') f = -1;",
			"            c = gc();",
			"        }",
			"        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
			"        return x = x * f;",
			"    }",
			"",
			"    template<typename... T> auto read(T&... x) { return (rd(x),...); }   ",
			"    #undef gc",
			"",
			"    struct IO {",
			"        template<typename T> friend IO&",
			"        operator>>(IO &io, T& x) { rd(x); return io; }",
			"    } static io;",
			"}",
			"using fast_io::read,fast_io::io;",
		],
		"description": "fast input based on fread",
	},
	

	"Fast IO": {
		"prefix": "#fast_io",
		"body": [
			"namespace fast_io {",
			"    constexpr int MAXBUF = 1 << 20, MAXLEN = 1 << 20;",
			"    char buf[MAXBUF], *pl, *pr;",
			"    char str[MAXLEN];",
			"",
			"    #define gc() \\",
			"    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
			"    ? EOF : *pl++)",
			"",
			"    template<typename T> T rd(T &x) {",
			"        x = 0;",
			"        T f = 1;",
			"        char c = gc();",
			"        while (!isdigit(c)) {",
			"            if (c == '-') f = -1;",
			"            c = gc();",
			"        }",
			"        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
			"        if (c != '.') return x = x * f;",
			"        for (double t = 0.1; c = gc(), isdigit(c); t *= 0.1) x += (c - '0') * t;",
			"        return x = x * f;",
			"    }",
			"",
			"    char* rd(char *p = str) {",
			"        char c = gc(), *h = p;",
			"        while (!isgraph(c)) c = gc();",
			"        while (isgraph(c)) *p++ = c, c = gc();",
			"        *p = '\\0';",
			"        return h;",
			"    }",
			"",
			"    char rd(char &c) {",
			"        c = gc();",
			"        while (!isgraph(c)) c = gc();",
			"        return c;",
			"    }",
			"",
			"    string rd(string &s) { return s = rd(str); }",
			"",
			"    template<typename... T> auto read(T&... x) { return (rd(x),...); }",
			"    #undef gc",
			"",
			"    constexpr int MAXPBUF = 1 << 20, PRECISION = 7;",
			"    char pbuf[MAXPBUF], *pp = pbuf;",
			"",
			"    void clear_buffer() { fwrite(pbuf, 1, pp-pbuf, stdout), pp = pbuf; }",
			"",
			"    void push(const char &c) {",
			"        if (pp - pbuf == MAXPBUF) clear_buffer();",
			"        *pp++ = c;",
			"    }",
			"",
			"    template<typename T> void wt(T x) {",
			"        if (x < 0) push('-'), x = -x;",
			"        static int sta[40];",
			"        int top = 0;",
			"        do {",
			"            sta[top++] = x % 10;",
			"        } while (x/=10);",
			"        while (top) push(sta[--top] + '0');",
			"    }",
			"",
			"    template<typename T> void wt_f(T x,int p) {",
			"        if (x < 0) push('-'), x = -x;",
			"        long long pre = (long long)x;",
			"        wt(pre);",
			"        x -= pre;",
			"        if (p) push('.');",
			"        while (p--) {",
			"            x *= 10;",
			"            int t = (int)x;",
			"            x -= t;",
			"            push(t + '0');",
			"        }",
			"    }",
			"",
			"    void wt(const char &c) { push(c); }",
			"    void wt(const string &s) { for (auto &x:s) push(x); }",
			"    void wt(const char *p) { while (*p != '\\0') push(*p++); }",
			"",
			"    void wt(const float &x, int p = PRECISION) { wt_f(x,p); }",
			"    void wt(const double &x, int p = PRECISION) { wt_f(x,p); }",
			"    void wt(const long double &x, int p = PRECISION) { wt_f(x,p); }",
			"",
			"    template<typename... T> void write(const T&... x) { (wt(x),...); }",
			"    template<typename T> void writef(const T &x,const int &p) { wt_f(x,p); }",
			"",
			"    struct IO {",
			"        template<typename T> friend IO& ",
			"        operator>>(IO &io, T& x) { rd(x); return io; }",
			"",
			"        template<typename T> friend IO&",
			"        operator<<(IO &io, const T& x) { wt(x); return io; }",
			"",
			"        ~IO() { clear_buffer(); }",
			"    } static io;",
			"",
			"} using fast_io::read,fast_io::write,fast_io::writef,fast_io::io;"
		],
		"description": [
			"fast input/output based on fread/fwrite",
			"",
			"基于fread和fwrite的快读快写",
			"",
			"## Usage:",
			"1. read(x);                 读入一个变量",
			"2. write(x);                输出一个变量",
			"3. write(x,y);              输出精度为y的浮点数x,精度默认值为PRECISION",
			"4. reads(...); writes(...); 多参数读写,不支持精度控制且无返回值",
			"5. io::clear_buffer();      手动清空输出缓冲",
			"",
			"## Features:",
			"1. 支持 int,long long,int128,float,double,long double,char(array),string",
			"2. 退出程序会自动清空输出缓冲",
			"",
			"## Parameters:",
			"1. MAXBUF/MAXPBUF 读入/输出缓存大小,数值越大越占内存,fread/fwrite执行的操作越少",
			"                  BUF的大小不影响功能,通常保持不变即可,预设大小的缓存数组会占用3-4M内存",
			"2. MAXLEN         单个字符串长度,字符串的最大连续长度,如果超出则会发生数组越界",
			"3. PRECISION      默认精度",
			"",
			"## Note:",
			"1. 不需要using namespace io,已经define了read和write",
			"2. 不要关闭同步流(std::ios::sync_with_stdio(true);)",
			"3. 如果使用了read,那么不能再使用其他输入函数例如scanf和cin,会导致io顺序错误",
			"   write同理,这是由快读快写的缓冲机制决定的,除非事先清空缓冲",
			"4. 浮点数输出不会执行四舍五入,并且可能输出-0"
		]
	},

	
	  //==============================//
	 //=============misc=============//
	//==============================//

	"time duration": {
		"prefix": "#time",
		"body": [
			"chrono::system_clock clock;",
			"auto t0=clock.now();",
			"${0:/* code */}",
			"chrono::duration<double,milli> dur=clock.now()-t0;",
			"cout<<\"Executed in \"<<dur.count()<<\" ms\"<<endl;",
		],
		"description": "",
	},	
	
	
	  //==============================//
	 //====algorithm:basic & misc====//
	//==============================//

	"lowbit": {
		"prefix": "#lowbit",
		"body": [
			"#define lowbit(x) (x&(-x))",
		],
		"description": "get the lowest bit of x",
	},

	"quick power": {
		"prefix": "#qpow",
		"body": [
			"LL qpow(LL a,LL b) {",
			"    LL res=1;",
			"    while(b) {",
			"        if(b&1) res=res*a${1:%mod};",
			"        b>>=1;",
			"        a=a*a${1:%mod};",
			"    }",
			"    return res;",
			"}",
		],
		"description": "quick power O(logn)",
	},

	"discrete (binary search)": {
		"prefix": "#discrete_bs",
		"body": [
			"sort(${1:num}.begin(),${1:num}.end());",
			"${1:num}.erase(unique(${1:num}.begin(),${1:num}.end()),${1:num}.end());",
			"for(int i=1;i<=n;i++) ",
			"    ${2:arr}[i]=lower_bound(${1:num}.begin(),${1:num}.end(),${2:arr}[i])-${1:num}.begin()+1;",
			"",
		],
		"description": "离散化 (排序+二分) O(nlogn)",
	},

	"modint": {
		"prefix": "#modint",
		"body": [
			"template<typename I,typename L,I mod> struct Modint {",
			"    I v;",
			"    I pow(L b) const {",
			"        L res=1,a=v;",
			"        while(b) { if(b&1) res=res*a%mod; b>>=1; a=a*a%mod; }",
			"        return res;",
			"    }",
			"    I inv() const { return pow(mod-2); }",
			"",
			"    Modint &operator+=(const Modint &x) { v+=x.v; v-=v>=mod?mod:0; return *this; }",
			"    Modint &operator-=(const Modint &x) { v-=x.v; v+=v<0?mod:0; return *this; }",
			"    Modint &operator*=(const Modint &x) { v=L(1)*v*x.v%mod; return *this; }",
			"    Modint &operator/=(const Modint &x) { v=L(1)*v*x.inv()%mod; return *this; }",
			"",
			"    friend Modint operator+(Modint l,const Modint &r) { return l+=r; }",
			"    friend Modint operator-(Modint l,const Modint &r) { return l-=r; }",
			"    friend Modint operator*(Modint l,const Modint &r) { return l*=r; }",
			"    friend Modint operator/(Modint l,const Modint &r) { return l/=r; }",
			"",
			"    Modint operator++(int) { auto res=*this; *this+=1; return res; }",
			"    Modint operator--(int) { auto res=*this; *this-=1; return res; }",
			"    Modint operator-  () { return *this*-1; }",
			"    Modint &operator++() { return *this+=1; }",
			"    Modint &operator--() { return *this-=1; }",
			"",
			"    bool operator< (const Modint&x) { return v< x.v; }",
			"    bool operator> (const Modint&x) { return v> x.v; }",
			"    bool operator<=(const Modint&x) { return v<=x.v; }",
			"    bool operator>=(const Modint&x) { return v>=x.v; }",
			"    bool operator==(const Modint&x) { return v==x.v; }",
			"    bool operator!=(const Modint&x) { return v!=x.v; }",
			"",
			"    friend istream &operator>>(istream &is,Modint &x) { return is>>x.v; }",
			"    friend ostream &operator<<(ostream &os,const Modint &x) { return os<<x.v; }",
			"",
			"    Modint(L x=0): v((x%=mod)<0?x+mod:x) {}",
			"    static_assert(0ULL+mod+mod-2<1ULL<<(sizeof(I)*8-1), \"Modint overflow\");",
			"    static_assert(1ULL*(mod-1)*(mod-1)<1ULL<<(sizeof(L)*8-1), \"Modint overflow\");",
			"    ",
			"}; using Mint=Modint<int,long long,998244353>;",
		],
		"description": "Modulo Automation",
	},

	"HashArray": {
		"prefix": "#hash",
		"body": [
			"template<int NUM,int MAX=127,class T=mt19937> struct HashArray {",
			"    using ULL=unsigned long long;",
			"    using ARR=array<ULL,NUM>;",
			"    T gen;",
			"    int P[NUM];",
			"    vector<ULL> val[NUM];",
			"",
			"    ULL qpow(ULL a,ULL b) {",
			"        ULL res=1;",
			"        while(b) {",
			"            if(b&1) res=res*a;",
			"            b>>=1;",
			"            a=a*a;",
			"        }",
			"        return res;",
			"    }",
			"    void init() {",
			"        for(int i=0;i<NUM;i++) {",
			"            val[i].push_back(0);",
			"            P[i]=gen();",
			"            while(P[i]<=MAX) P[i]=gen();",
			"        }",
			"    }",
			"",
			"    void push_back(int x) {",
			"        for(int i=0;i<NUM;i++) {",
			"            ULL t=val[i].back();",
			"            val[i].push_back(t*P[i]+x);",
			"        }",
			"    }",
			"    ",
			"    void append(string &x) {",
			"        for(auto s:x) push_back(s);",
			"    }",
			"",
			"    ARR query(int l,int r) {",
			"        ARR res;",
			"        for(int i=0;i<NUM;i++) res[i]=(val[i][r]-val[i][l-1]*qpow(P[i],r-l+1));",
			"        return res;",
			"    }",
			"",
			"    bool match(int l,int r,int L,int R) {",
			"        return query(l,r)==query(L, R);",
			"    }",
			"",
			"    HashArray(T x): gen(x) { init(); }",
			"};",
		],
		"description": "Hash",
	},

	"Sparse Table": {
		"prefix": "#st",
		"body": [
			"template<typename T=int> struct SparseTable {",
			"    constexpr static int N=1e5+10,M=20;",
			"    T arr[N],st[M][N];",
			"",
			"    void build(int n) {",
			"        for(int i=1;i<=n;i++) st[0][i]=arr[i];",
			"        for(int k=1,t=1<<k;k<M;k++,t<<=1)",
			"            for(int i=1,j=i+t-1,mid=i+t/2;j<=n;i++,j++,mid++)",
			"                st[k][i]=max(st[k-1][i],st[k-1][mid]);",
			"    }",
			"",
			"    T query(int l,int r) {",
			"        if(r<l) return 0;",
			"        int k=__lg(r-l+1);",
			"        return max(st[k][l],st[k][r-(1<<k)+1]);",
			"    }",
			"};",
		],
		"description": "Sparse Table",
	},	
	

	  //==============================//
	 //=======algorithm:trees========//
	//==============================//

	"FenwickTree": {
		"prefix": "#fenwick",
		"body": [
			"template<typename T=int> ",
			"struct Fenwick {",
			"    std::vector<T> tr;",
			"    int sz=0;",
			"",
			"    int lowbit(int x) { return x&(-x); }",
			"",
			"    void update(T &aim,T &val) {",
			"        aim+=val;",
			"    }",
			"",
			"    void add(int pos,T val) {",
			"        while(pos<=sz) update(tr[pos],val),pos+=lowbit(pos);",
			"    }",
			"",
			"    T query(int pos) {",
			"        T res=0;",
			"        while(pos) update(res,tr[pos]),pos-=lowbit(pos);",
			"        return res;",
			"    }",
			"",
			"    Fenwick(int n) { tr.resize(sz=n+1); }",
			"};",
		],
		"description": "FenwickTree",
	},

	"heavy path decomposition": {
		"prefix": "#heavy-path-decomposition",
		"body": [
			"namespace hpd {",
			"    using PII=pair<int,int>;",
			"    constexpr int N=${1:1e5+10};",
			"    int id[N],w[N],nw[N],cnt;",
			"    int dep[N],sz[N],top[N],p[N],hch[N];",
			"    vector<int> adj[N];",
			"",
			"    void dfs1(int u,int fa,int d) {",
			"        dep[u]=d,p[u]=fa,sz[u]=1;",
			"        for(int v:adj[u]) {",
			"            if(v==fa) continue;",
			"            dfs1(v,u,d+1);",
			"            sz[u]+=sz[v];",
			"            if(sz[hch[u]]<sz[v]) hch[u]=v;",
			"        }",
			"    }",
			"",
			"    void dfs2(int u,int t) {",
			"        id[u]=++cnt,nw[cnt]=w[u],top[u]=t;",
			"        if(!hch[u]) return;",
			"        dfs2(hch[u],t);",
			"        for(int v:adj[u])",
			"            if(v!=p[u]&&v!=hch[u]) dfs2(v,v);",
			"    }",
			"",
			"    void init() {",
			"        // cnt,hch -> 0",
			"        dfs1(1,-1,1); dfs2(1,1);",
			"    }",
			"",
			"    vector<PII> decompose(int x,int y) {",
			"        vector<PII> res;",
			"        while(top[x]!=top[y]) {",
			"            if(dep[top[x]]<dep[top[y]]) swap(x,y);",
			"            res.emplace_back(id[top[x]],id[x]);",
			"            x=p[top[x]];",
			"        }",
			"        if(dep[x]<dep[y]) swap(x,y);",
			"        res.emplace_back(id[y],id[x]);",
			"        return res;",
			"    }",
			"",
			"    PII decompose(int x) {",
			"        return { id[x],id[x]+sz[x]-1 };",
			"    }",
			"}",
		],
		"description": [
			"将树上路径转化为不超过logn级别数量的线段 预处理复杂度 O(n) ",
			"需要初始化为0的变量: idx,cnt,h[],hch[]",
			"预处理: dfs1(1,-1,1); dfs2(1,1);"
		],
	},

	"Treap": {
		"prefix": "#treap",
		"body": [
			"const int N=1e5+10,INF=0x3f3f3f3f;",
			"",
			"struct NODE{",
			"    int l,r;",
			"    int key,val;",
			"    int cnt,size;",
			"}tr[N];",
			"int root,idx;",
			"",
			"int new_node(int key){",
			"    tr[++idx].key=key;",
			"    tr[idx].val=rand();",
			"    tr[idx].cnt=tr[idx].size=1;",
			"    return idx;",
			"}",
			"",
			"void pushup(int id){",
			"    tr[id].size=tr[tr[id].l].size+tr[tr[id].r].size+tr[id].cnt;",
			"}",
			"",
			"void zag(int &p){",
			"    int q=tr[p].r;",
			"    tr[p].r=tr[q].l,tr[q].l=p;",
			"    pushup(p),pushup(q);",
			"    p=q;",
			"}",
			"",
			"void zig(int &p){",
			"    int q=tr[p].l;",
			"    tr[p].l=tr[q].r,tr[q].r=p;",
			"    pushup(p),pushup(q);",
			"    p=q;",
			"}",
			"",
			"void insert(int &p,int key){",
			"    if(!p) p=new_node(key);",
			"    else if(tr[p].key==key) tr[p].cnt++;",
			"    else if(key<tr[p].key) {",
			"        insert(tr[p].l,key);",
			"        if(tr[tr[p].l].val>tr[p].val) zig(p);",
			"    }",
			"    else {",
			"        insert(tr[p].r,key);",
			"        if(tr[tr[p].r].val>tr[p].val) zag(p);",
			"    }",
			"    pushup(p);",
			"}",
			"",
			"void erase(int &p,int key){",
			"    if(!p) return;",
			"    if(tr[p].key==key){",
			"        if(tr[p].cnt>1) tr[p].cnt--;",
			"        else if(!tr[p].l&&!tr[p].r) p=0;",
			"        else if(!tr[p].l||tr[tr[p].r].val>tr[tr[p].l].val)",
			"            zag(p),erase(tr[p].l,key);",
			"        else zig(p),erase(tr[p].r,key);",
			"    }",
			"    else if(key<tr[p].key) erase(tr[p].l,key);",
			"    else erase(tr[p].r,key);",
			"    pushup(p);",
			"}",
			"",
			"int get_rank(int p,int key){",
			"    if(!p) return INF;",
			"    if(tr[p].key==key) return tr[tr[p].l].size+1;",
			"    else if(key<tr[p].key) return get_rank(tr[p].l,key);",
			"    return tr[tr[p].l].size+tr[p].cnt+get_rank(tr[p].r,key);",
			"}",
			"",
			"int get_key(int p,int rank){",
			"    if(!p) return INF;",
			"    int lrank=tr[tr[p].l].size;",
			"    if(rank<=lrank) return get_key(tr[p].l,rank);",
			"    else if(rank<=lrank+tr[p].cnt) return tr[p].key;",
			"    return get_key(tr[p].r,rank-lrank-tr[p].cnt);",
			"}",
			"",
			"int get_prev(int p,int key){",
			"    if(!p) return -INF;",
			"    if(tr[p].key>=key) return get_prev(tr[p].l,key);",
			"    return max(tr[p].key,get_prev(tr[p].r,key));",
			"}",
			"",
			"int get_next(int p,int key){",
			"    if(!p) return INF;",
			"    if(tr[p].key<=key) return get_next(tr[p].r,key);",
			"    return min(tr[p].key,get_next(tr[p].l,key));",
			"}",
			"",
			"void build(){",
			"    root=new_node(-INF);",
			"    tr[root].r=new_node(INF);",
			"    pushup(root);",
			"    if(tr[1].val<tr[2].val) zag(root);",
			"}",
		],
		"description": "Treap",
	},
	
	"Chtholly Tree": {
		"prefix": "#odt",
		"body": [
			"struct ChthollyTree {",
			"    struct Node {",
			"        int l,r,v;",
			"        Node(int L,int R,int V) : l(L),r(R),v(V) {}",
			"        bool operator< (const Node &x) const {",
			"            return l<x.l;",
			"        }",
			"    };",
			"    set<Node> st;",
			"",
			"    auto split(int pos){",
			"        auto it=st.lower_bound(Node(pos,pos,0));",
			"        if(it!=st.end()&&it->l==pos) return it;",
			"        it=prev(it);",
			"        auto [l,r,v]=*it;",
			"        st.erase(it);",
			"        st.insert(Node(l,pos-1,v));",
			"        return st.insert(Node(pos,r,v)).first;",
			"    }",
			"",
			"    void assign(int l,int r,int v){",
			"        auto end=split(r+1),begin=split(l);",
			"        st.erase(begin,end);",
			"        st.insert(Node(l,r,v));",
			"    }",
			"} odt;",
		],
		"description": "Chtholly Tree",
	},

	"Link Cut Tree": {
		"prefix": "#lct",
		"body": [
			"struct LinkCutTree {",
			"    ",
			"    #define lch tr[u].ch[0]",
			"    #define rch tr[u].ch[1]",
			"    #define wch(u) (tr[tr[u].p].ch[1]==u)",
			"    constexpr static int MAX_SIZE=1e5+10;",
			"",
			"    struct Node {",
			"        int ch[2],p;",
			"        bool rev;",
			"        ",
			"    } tr[MAX_SIZE];",
			"    int stk[MAX_SIZE];",
			"",
			"    bool is_root(int u) {",
			"        return tr[tr[u].p].ch[0]!=u&&tr[tr[u].p].ch[1]!=u;",
			"    }",
			"",
			"    void pushup(int u) {",
			"        ",
			"    }",
			"",
			"    void pushrev(int u) {",
			"        swap(lch,rch);",
			"        tr[u].rev^=1;",
			"    }",
			"",
			"    void pushdn(int u) {",
			"        if(tr[u].rev) pushrev(lch),pushrev(rch),tr[u].rev=0;",
			"    }",
			"",
			"    void rotate(int x) {",
			"        int y=tr[x].p,z=tr[y].p,k=wch(x);",
			"        if(!is_root(y)) tr[z].ch[wch(y)]=x;",
			"        tr[y].ch[k]=tr[x].ch[!k],tr[tr[y].ch[k]].p=y;",
			"        tr[x].ch[!k]=y,tr[y].p=x,tr[x].p=z;",
			"        pushup(y),pushup(x);",
			"    }",
			"",
			"    void splay(int u) {",
			"        int top=0,fa=u;",
			"        stk[++top]=fa;",
			"        while(!is_root(fa)) stk[++top]=fa=tr[fa].p;",
			"        while(top) pushdn(stk[top--]);",
			"        for(;!is_root(u);rotate(u))",
			"            if(!is_root(fa=tr[u].p)) rotate(wch(u)==wch(fa)?fa:u);",
			"    }",
			"",
			"    void access(int u) {",
			"        int t=u;",
			"        for(int v=0;u;v=u,u=tr[u].p)",
			"            splay(u),rch=v,pushup(u);",
			"        splay(t);",
			"    }",
			"",
			"    void make_root(int u) {",
			"        access(u);",
			"        pushrev(u);",
			"    }",
			"",
			"    int split(int u,int v) {",
			"        make_root(u);",
			"        access(v);",
			"        return v;",
			"    }",
			"",
			"    int find_root(int u) {",
			"        access(u);",
			"        while(lch) pushdn(u),u=lch;",
			"        splay(u);",
			"        return u;",
			"    }",
			"",
			"    void link(int u,int v) {",
			"        make_root(u);",
			"        if(find_root(v)!=u) tr[u].p=v;",
			"    }",
			"",
			"    void cut(int u,int v) {",
			"        make_root(u);",
			"        if(find_root(v)==u&&rch==v&&!tr[v].ch[0])",
			"            rch=tr[v].p=0,pushup(u);",
			"    }",
			"",
			"    void modify(int u,int val) {",
			"        splay(u);",
			"",
			"        pushup(u);",
			"    }",
			"",
			"    #undef lch",
			"    #undef rch",
			"    #undef wch",
			"",
			"} lct;",
		],
		"description": "Link Cut Tree",
	},

	"Segment Tree": {
		"prefix": "#segment_tree",
		"body": [
			"struct SegmentTree {",
			"    #define lch (u<<1)",
			"    #define rch (u<<1|1)",
			"    constexpr static int MAXSIZE=${1:N};",
			"",
			"    struct Node {",
			"        int l,r;",
			"",
			"    } tr[MAXSIZE<<2];",
			"",
			"    void pushup(int u) {",
			"",
			"    }",
			"",
			"    void pushdn(int u) {",
			"",
			"    }",
			"",
			"    void modify(int u,int l,int r,int val) {",
			"        if(tr[u].l>=l&&tr[u].r<=r) {}",
			"        else {",
			"            pushdn(u);",
			"            int mid=tr[u].l+tr[u].r>>1;",
			"            if(mid>=l) modify(lch, l, r, val);",
			"            if(mid<r) modify(rch, l, r, val);",
			"            pushup(u);",
			"        }",
			"    }",
			"",
			"    int query(int u,int l,int r) {",
			"        if(tr[u].l>=l&&tr[u].r<=r) {}",
			"        else {",
			"            pushdn(u);",
			"            int mid=tr[u].l+tr[u].r>>1;",
			"            ",
			"            if(mid>=l) query(lch, l, r);",
			"            if(mid<r) query(rch, l, r);",
			"        }",
			"    }",
			"",
			"    void build(int u,int l,int r) {",
			"        tr[u]={l,r};",
			"        if(l==r) {}",
			"        else {",
			"            int mid=l+r>>1;",
			"            build(lch, l, mid);",
			"            build(rch, mid+1, r);",
			"            pushup(u);",
			"        }",
			"    }",
			"",
			"    #undef lch",
			"    #undef rch",
			"} sgt;",
		],
		"description": "Segment Tree",
	},

	"Merge Split Segment Tree": {
		"prefix": "#merge_split_segment_tree",
		"body": [
			"struct MergeSplitSegmentTree {",
			"",
			"    #define lch tr[u].ch[0]",
			"    #define rch tr[u].ch[1]",
			"    constexpr static int MAX_SIZE=1e7+10;",
			"    ",
			"    struct Node {",
			"        int ch[2];",
			"        int cnt;",
			"    } tr[MAX_SIZE];",
			"    int idx;",
			"",
			"    int new_node() {",
			"        // assert(idx<MAX_SIZE);",
			"        return ++idx;",
			"    }",
			"",
			"    void pushup(int u) {",
			"        if(lch&&rch) ;",
			"        else if(lch) ;",
			"        else if(rch) ;",
			"    }",
			"",
			"    // remember to pushdn laze tag",
			"    void pushdn(int u) {",
			"        if(lch) ;",
			"        if(rch) ;",
			"",
			"    }",
			"    ",
			"    void merge(int &u,int v) {",
			"        if(!u&&!v) return;",
			"        if(!u||!v) u=u|v;",
			"        else {",
			"            pushdn(u);pushdn(v);",
			"            merge(lch,tr[v].ch[0]);",
			"            merge(rch,tr[v].ch[1]);",
			"            pushup(u);",
			"        }",
			"    }",
			"",
			"    // k][k+1",
			"    void split(int &u,int &v,int l,int r,int k) {",
			"        if(!u||k>=r) return;",
			"        if(k<l) swap(u,v);",
			"        else {",
			"            v=new_node();",
			"            int mid=l+r>>1;",
			"            if(k<=mid) swap(rch,tr[v].ch[1]);",
			"            pushdn(u);",
			"            if(k<mid) split(lch, tr[v].ch[0], l, mid, k);",
			"            else split(rch, tr[v].ch[1], mid+1, r, k);",
			"            pushup(u),pushup(v);",
			"        }",
			"    }",
			"",
			"    int kth(int u,int l,int r,int k) {",
			"        if(tr[u].cnt<k) return -1;",
			"        if(l==r) return l;",
			"        int mid=l+r>>1;",
			"        pushdn(u);",
			"        if(tr[lch].cnt>=k) return kth(lch, l, mid, k);",
			"        return kth(rch, mid+1, r, k-tr[lch].cnt);",
			"    }",
			"",
			"    void build(int &u,int l,int r,int p) {",
			"        u=new_node();",
			"        if(l==r) ;",
			"        else {",
			"            int mid=l+r>>1;",
			"            if(p<=mid) build(lch,l,mid,p);",
			"            else build(rch,mid+1,r,p);",
			"            pushup(u);",
			"        }",
			"    }",
			"",
			"    #undef lch",
			"    #undef rch",
			"",
			"} sgt;",
		],
		"description": [
			"线段树合并&分裂",
			"[时间复杂度] 无论以何种顺序合并与分裂,时间复杂度为O((n+m)logn) (m为分裂次数)",
			"[空间复杂度] O((n+m)logn) 直接合并为(n+m)logn,不破坏子树结构为2(n+m)logn"
		],
	},	
	
	"Persistent Segment Tree": {
		"prefix": "#persistent_segment_tree",
		"body": [
			"struct PersistentSegmentTree {",
			"",
			"    #define lch tr[u].ch[0]",
			"    #define rch tr[u].ch[1]",
			"    constexpr static int MAX_SIZE=N*20*2;",
			"",
			"    struct Node {",
			"        int ch[2];",
			"        int cnt;",
			"    } tr[MAX_SIZE];",
			"    int idx;",
			"",
			"    int new_node() {",
			"        // assert(idx<MAX_SIZE);",
			"        return ++idx;",
			"    }",
			"",
			"    void pushup(int u) {",
			"        tr[u].cnt=tr[lch].cnt+tr[rch].cnt;",
			"    }",
			"",
			"    void modify(int &u,int v,int l,int r,int p) {",
			"        u=new_node();",
			"        tr[u]=tr[v];",
			"        if(l==r) tr[u].cnt++;",
			"        else {",
			"            int mid=l+r>>1;",
			"            if(p<=mid) modify(lch, tr[v].ch[0], l, mid, p);",
			"            else modify(rch, tr[v].ch[1], mid+1, r, p);",
			"            pushup(u);",
			"        }",
			"    }",
			"",
			"    int kth(int u,int v,int l,int r,int k) {",
			"        if(l==r) return l;",
			"        int mid=l+r>>1;",
			"        int lcnt=tr[lch].cnt-tr[tr[v].ch[0]].cnt;",
			"        if(lcnt>=k) return kth(lch, tr[v].ch[0], l, mid, k);",
			"        return kth(rch, tr[v].ch[1], mid+1, r, k-lcnt);",
			"    }",
			"",
			"    void build(int &u,int l,int r) {",
			"        u=new_node();",
			"        tr[u]={l,r};",
			"        if(l!=r) {",
			"            int mid=l+r>>1;",
			"            build(lch,l,mid);",
			"            build(rch,mid+1,r);",
			"        }",
			"    }",
			"",
			"    #undef lch",
			"    #undef rch",
			"",
			"} sgt;",
		],
		"description": "Persistent Segment Tree",
	},
	

	  //==============================//
	 //=======algorithm:string=======//
	//==============================//

	"KMP": {
		"prefix": "#kmp",
		"body": [
			"void kmp_build(int n) {",
			"    for(int i=2,j=0;i<=n;i++) {",
			"        while(j&&t[i]!=t[j+1]) j=link[j];",
			"        if(t[i]==t[j+1]) j++;",
			"        link[i]=t[i+1]==t[j+1]?link[j]:j; ",
			"    }",
			"}",
		],
		"description": "KMP",
	},	

	"Aho-Corasick Automaton": {
		"prefix": "#acam",
		"body": [
			"struct AhoCorasickAutomaton {",
			"    const static int A=26;",
			"    const static char B='a';",
			"    struct Node {",
			"        int link,cnt;",
			"        int ch[A];",
			"    };",
			"",
			"    vector<Node> tr;",
			"    int sz=0;",
			"",
			"    int insert(string &s) {",
			"        int root=0;",
			"        for(auto x:s) {",
			"            int c=x-B;",
			"            if(!tr[root].ch[c]) ",
			"                tr[root].ch[c]=new_node();",
			"            root=tr[root].ch[c];",
			"        }",
			"        tr[root].cnt++;",
			"        return root;",
			"    }",
			"",
			"    void build() {",
			"        queue<int> q;",
			"        for(int i=0;i<A;i++) ",
			"            if(tr[0].ch[i]) {",
			"                q.push(tr[0].ch[i]);",
			"",
			"            }",
			"        while(q.size()) {",
			"            auto root=q.front();",
			"            q.pop();",
			"            for(int i=0;i<A;i++) {",
			"                int &cur=tr[root].ch[i];",
			"                int pre=tr[tr[root].link].ch[i];",
			"                if(!cur) cur=pre;",
			"                else {",
			"                    // tr[cur].cnt+=tr[pre].cnt;",
			"                    tr[cur].link=pre;",
			"                    q.push(cur);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    int match() {",
			"",
			"    }",
			"",
			"    int size() { return tr.size(); }",
			"    int new_node() { tr.push_back({});return ++sz; }",
			"    void clear() { tr.clear();tr.resize(1);sz=0; }",
			"",
			"    AhoCorasickAutomaton() { tr.resize(1); }",
			"    AhoCorasickAutomaton(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
			"} acam;",
		],
		"description": "Aho-Corasick Automaton",
	},	

	"Aho-Corasick Automaton with fail tree": {
		"prefix": "#acam_fail",
		"body": [
			"struct AhoCorasickAutomaton {",
			"    const static int A=26;",
			"    const static char B='a';",
			"    struct Node {",
			"        int link,cnt;",
			"        int ch[A];",
			"        vector<int> adj;",
			"    };",
			"",
			"    vector<Node> tr;",
			"    vector<int> id,ed;",
			"    int sz=0,idx=0;",
			"",
			"    int insert(string &s) {",
			"        int root=0;",
			"        for(auto x:s) {",
			"            int c=x-B;",
			"            if(!tr[root].ch[c]) ",
			"                tr[root].ch[c]=new_node();",
			"            root=tr[root].ch[c];",
			"        }",
			"        tr[root].cnt++;",
			"        return root;",
			"    }",
			"",
			"    void build() {",
			"        queue<int> q;",
			"        for(int i=0;i<A;i++) ",
			"            if(tr[0].ch[i]) {",
			"                q.push(tr[0].ch[i]);",
			"                tr[0].adj.push_back(tr[0].ch[i]);",
			"",
			"            }",
			"        while(q.size()) {",
			"            auto root=q.front();",
			"            q.pop();",
			"            for(int i=0;i<A;i++) {",
			"                int &cur=tr[root].ch[i];",
			"                int pre=tr[tr[root].link].ch[i];",
			"                if(!cur) cur=pre;",
			"                else {",
			"                    // tr[cur].cnt+=tr[pre].cnt;",
			"                    tr[cur].link=pre;",
			"                    tr[pre].adj.push_back(cur);",
			"                    q.push(cur);",
			"                }",
			"            }",
			"        }",
			"",
			"        id.resize(size());",
			"        ed.resize(size());",
			"        relabel(0);",
			"    }",
			"",
			"    void relabel(int u) {",
			"        id[u]=++idx;",
			"        for(int v:tr[u].adj) relabel(v);",
			"        ed[u]=idx;",
			"    }",
			"    ",
			"    int match() {",
			"",
			"    }",
			"",
			"    int size() { return tr.size(); }",
			"    int new_node() { tr.push_back({});return ++sz; }",
			"    void clear() { tr.clear();tr.resize(1);sz=idx=0; }",
			"",
			"    AhoCorasickAutomaton() { tr.resize(1); }",
			"    AhoCorasickAutomaton(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
			"} acam;",
		],
		"description": "Aho-Corasick Automaton with fail tree",
	},	

	"Suffix Array": {
		"prefix": "#sa",
		"body": [
			"constexpr int N=${1:1e6+10};",
			"",
			"int n,m=1<<7;",
			"string s;",
			"int fir[N],sec[N],cnt[N];",
			"int sa[N],rk[N],height[N];",
			"",
			"void get_sa() {",
			"    for(int i=1;i<=n;i++) cnt[fir[i]=s[i]]++;",
			"    for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
			"    for(int i=n;i;i--) sa[cnt[fir[i]]--]=i;",
			"",
			"    for(int k=1;k<=n;k<<=1) {",
			"        int num=0;",
			"        for(int i=n-k+1;i<=n;i++) sec[++num]=i;",
			"        for(int i=1;i<=n;i++) if(sa[i]>k) sec[++num]=sa[i]-k;",
			"        for(int i=1;i<=m;i++) cnt[i]=0;",
			"        for(int i=1;i<=n;i++) cnt[fir[i]]++;",
			"        for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
			"        for(int i=n;i;i--) sa[cnt[fir[sec[i]]]--]=sec[i],sec[i]=0;",
			"        swap(fir,sec);",
			"        fir[sa[1]]=num=1;",
			"        for(int i=2;i<=n;i++)",
			"            fir[sa[i]]=(sec[sa[i]]==sec[sa[i-1]]&&sec[sa[i]+k]==sec[sa[i-1]+k])",
			"                ?num:++num;",
			"        if(num==n) break;",
			"        m=num;",
			"    }",
			"}",
			"",
			"void get_height() {",
			"    for(int i=1;i<=n;i++) rk[sa[i]]=i;",
			"    for(int i=1,k=0;i<=n;i++) {",
			"        if(rk[i]==1) continue;",
			"        if(k) k--;",
			"        int j=sa[rk[i]-1];",
			"        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;",
			"        height[rk[i]]=k;",
			"    }",
			"}",
		],
		"description": "倍增法求后缀数组 O(nlogn)",
	},

	"Suffix Automaton": {
		"prefix": "#sam",
		"body": [
			"struct SuffixAutomaton {",
			"    constexpr static int A=26;",
			"    constexpr static char B='a';",
			"    struct Endpos {",
			"        int link,len;",
			"        int ch[A];",
			"    };",
			"    vector<Endpos> edp;",
			"    int last=0;",
			"",
			"    int new_node() {",
			"        edp.push_back({});",
			"        return edp.size()-1;",
			"    }",
			"",
			"    void extend(char x) {",
			"        int c=x-B;",
			"        int p=last;",
			"        int cur=last=new_node();",
			"        edp[cur].len=edp[p].len+1;",
			"        for(;p!=-1&&!edp[p].ch[c];p=edp[p].link) edp[p].ch[c]=cur;",
			"        if(p!=-1) {",
			"            int q=edp[p].ch[c];",
			"            if(edp[p].len+1==edp[q].len) edp[cur].link=q;",
			"            else {",
			"                int clone=new_node();",
			"                edp[clone]=edp[q];",
			"                edp[clone].len=edp[p].len+1; ",
			"                edp[cur].link=edp[q].link=clone;",
			"                for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link) ",
			"                    edp[p].ch[c]=clone;",
			"            }",
			"        }",
			"    }",
			"",
			"    void build(string &s) { for(auto x:s) extend(x); }",
			"    void clear() { edp.clear(),edp.push_back({-1}),last=0; }",
			"    int size() { return edp.size(); }",
			"    ",
			"    SuffixAutomaton() { edp.push_back({-1}); }",
			"    SuffixAutomaton(int sz) { edp.reserve(sz),edp.push_back({-1}); }",
			"} sam;",
		],
		"description": "Suffix Automaton",
	},

	"Suffix Automaton with Segment Tree": {
		"prefix": "#sam_sgt",
		"body": [
			"constexpr int N=1e6+10;",
			"int root[N],n;",
			"vector<int> adj[N];",
			"",
			"struct MergeSplitSegmentTree {",
			"",
			"    #define lch tr[u].l",
			"    #define rch tr[u].r",
			"    constexpr static int MAX_SIZE=N*40;",
			"    ",
			"    struct Node {",
			"        int l,r;",
			"    } tr[MAX_SIZE];",
			"    int idx;",
			"",
			"    int new_node() { return ++idx; }",
			"",
			"    int merge(int x,int y) {",
			"        if(!x||!y) return x|y;",
			"        int u=new_node();",
			"        lch=merge(tr[x].l,tr[y].l);",
			"        rch=merge(tr[x].r,tr[y].r);",
			"        return u;",
			"    }",
			"",
			"    bool __query(int u,int l,int r,int L,int R) {",
			"        if(l>=L&&r<=R) return 1;",
			"        int mid=l+r>>1;",
			"        bool res=0;",
			"        if(lch&&mid>=L) res|=__query(lch, l, mid, L, R);",
			"        if(rch&&mid<R) res|=__query(rch, mid+1, r, L, R);",
			"        return res;",
			"    }",
			"",
			"    bool query(int u,int L,int R) {",
			"        return L<=R&&__query(u, 1, n, L, R);",
			"    }",
			"",
			"    void build(int &u,int l,int r,int p) {",
			"        u=new_node();",
			"        if(l!=r) {",
			"            int mid=l+r>>1;",
			"            if(p<=mid) build(lch,l,mid,p);",
			"            else build(rch,mid+1,r,p);",
			"        }",
			"    }",
			"",
			"    #undef lch",
			"    #undef rch",
			"",
			"} sgt;",
			"",
			"struct SuffixAutomaton {",
			"    constexpr static int A=26;",
			"    constexpr static char B='a';",
			"    struct Endpos {",
			"        int link,len;",
			"        int ch[A];",
			"        bool mark;",
			"    };",
			"    vector<Endpos> edp;",
			"    int last=0;",
			"",
			"    int new_node() {",
			"        edp.push_back({});",
			"        return edp.size()-1;",
			"    }",
			"",
			"    void extend(char x) {",
			"        int c=x-B;",
			"        int p=last;",
			"        int cur=last=new_node();",
			"        edp[cur].len=edp[p].len+1;",
			"        for(;p!=-1&&!edp[p].ch[c];p=edp[p].link) edp[p].ch[c]=cur;",
			"        if(p!=-1) {",
			"            int q=edp[p].ch[c];",
			"            if(edp[p].len+1==edp[q].len) edp[cur].link=q;",
			"            else {",
			"                int clone=new_node();",
			"                edp[clone]=edp[q];",
			"                edp[clone].len=edp[p].len+1; ",
			"                edp[cur].link=edp[q].link=clone;",
			"                for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link) ",
			"                    edp[p].ch[c]=clone;",
			"            }",
			"        }",
			"    }",
			"",
			"    void merge(int u) {",
			"        for(int v:adj[u]) ",
			"            merge(v),root[u]=sgt.merge(root[u], root[v]);",
			"    }",
			"",
			"    void build_with_sgt(string &s) {",
			"        build(s);",
			"        for(int u=0,i=0;i<s.size();i++) {",
			"            int c=s[i]-B;",
			"            u=edp[u].ch[c];",
			"            sgt.build(root[u], 1, n, i+1);",
			"        }",
			"        for(int i=1;i<size();i++) adj[edp[i].link].push_back(i);",
			"        for(int v:adj[0]) merge(v);",
			"    }",
			"",
			"    void build(string &s) { for(auto x:s) extend(x); }",
			"    void clear() { edp.clear(),edp.push_back({-1}),last=0; }",
			"    int size() { return edp.size(); }",
			"    ",
			"    SuffixAutomaton() { edp.push_back({-1}); }",
			"    SuffixAutomaton(int sz) { edp.reserve(sz),edp.push_back({-1}); }",
			"} sam;",
		],
		"description": "线段树合并维护SAM endpos集合",
	},	

	"General Suffix Automaton (online version)": {
		"prefix": "#gsam",
		"body": [
			"struct GeneralSuffixAutomaton {",
			"    constexpr static int A=26;",
			"    constexpr static char B='a';",
			"    using Arr=array<int, A>;",
			"    struct Endpos {",
			"        int link,len;",
			"        Arr ch;",
			"    };",
			"    vector<Endpos> edp;",
			"    vector<Arr> tr;",
			"",
			"    void init() {",
			"        edp.clear(),edp.push_back({-1});",
			"        tr.clear(),tr.push_back({});",
			"    }",
			"",
			"    int new_tr() { tr.push_back({}); return tr.size()-1; }",
			"    int new_edp() { edp.push_back({}); return edp.size()-1; }",
			"",
			"    int split(int p,int c,int len) {",
			"        int q=edp[p].ch[c];",
			"        if(edp[q].len==len) return q;",
			"        else {",
			"            int clone=new_edp();",
			"            edp[clone]=edp[q];",
			"            edp[clone].len=len;",
			"            edp[q].link=clone;",
			"            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
			"                edp[p].ch[c]=clone;",
			"            return clone;",
			"        }",
			"    }",
			"",
			"    void extend(int &p,int &t,char x,int len) {",
			"        int c=x-B;",
			"        int last;",
			"        if(tr[t][c]) last=edp[p].ch[c];",
			"        else {",
			"            tr[t][c]=new_tr();",
			"            if(edp[p].ch[c]) last=split(p, c, len);",
			"            else {",
			"                int cur=last=new_edp();",
			"                edp[cur].len=len;",
			"                for(;p!=-1&&!edp[p].ch[c];p=edp[p].link)",
			"                    edp[p].ch[c]=cur;",
			"                if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
			"            }",
			"        }",
			"        t=tr[t][c];",
			"        p=last;",
			"    }",
			"",
			"    void extend(string &s) {",
			"        for(int p=0,t=0,i=0;i<s.size();i++) extend(p, t, s[i], i+1);",
			"    }",
			"",
			"    int size() { return edp.size(); }",
			"    void clear() { init(); }",
			"    ",
			"    GeneralSuffixAutomaton() { init(); }",
			"    GeneralSuffixAutomaton(int sz) { edp.reserve(sz),tr.reserve(sz),init(); }",
			"} sam;",
		],
		"description": "General Suffix Automaton (online version)",
	},

	"General Suffix Automaton (offline version, with trie)": {
		"prefix": "#gsam_offline_trie",
		"body": [
			"struct GeneralSuffixAutomaton {",
			"    constexpr static int A=26;",
			"    constexpr static char B='a';",
			"    using Arr=array<int, A>;",
			"    struct Endpos {",
			"        int link,len;",
			"        Arr ch;",
			"    };",
			"    vector<Endpos> edp;",
			"    vector<Arr> tr;",
			"",
			"    void init() {",
			"        edp.clear(),edp.push_back({-1});",
			"        tr.clear(),tr.push_back({});",
			"    }",
			"",
			"    int new_tr() { tr.push_back({}); return tr.size()-1; }",
			"    int new_edp() { edp.push_back({}); return edp.size()-1; }",
			"",
			"    int split(int p,int c,int len) {",
			"        int q=edp[p].ch[c];",
			"        if(edp[q].len==len) return q;",
			"        else {",
			"            int clone=new_edp();",
			"            edp[clone]=edp[q];",
			"            edp[clone].len=len;",
			"            edp[q].link=clone;",
			"            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
			"                edp[p].ch[c]=clone;",
			"            return clone;",
			"        }",
			"    }",
			"",
			"    int extend(int p,int c) {",
			"        int cur=new_edp();",
			"        edp[cur].len=edp[p].len+1;",
			"        for(;p!=-1&&!edp[p].ch[c];p=edp[p].link)",
			"            edp[p].ch[c]=cur;",
			"        if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
			"        return cur;",
			"    }",
			"",
			"    void insert(string &s) {",
			"        int t=0,c=0;",
			"        for(auto x:s) {",
			"            c=x-B;",
			"            if(!tr[t][c]) tr[t][c]=new_tr();",
			"            t=tr[t][c];",
			"        }",
			"    }",
			"",
			"    void build() {",
			"        queue<pair<int,int>> q;",
			"        q.emplace(0,0);",
			"        while(q.size()) {",
			"            auto [t,p]=q.front();",
			"            q.pop();",
			"            for(int c=0;c<A;c++) if(tr[t][c]) ",
			"                q.emplace(tr[t][c],extend(p, c));",
			"        }",
			"    }",
			"",
			"    int size() { return edp.size(); }",
			"    void clear() { init(); }",
			"    ",
			"    GeneralSuffixAutomaton() { init(); }",
			"    GeneralSuffixAutomaton(int sz) { edp.reserve(sz),tr.reserve(sz),init(); }",
			"} sam;",
		],
		"description": "General Suffix Automaton (offline version, with trie)",
	},	

	"General Suffix Automaton (offline version, without trie)": {
		"prefix": "#gsam_offline",
		"body": [
			"struct GeneralSuffixAutomaton {",
			"    constexpr static int A=26;",
			"    constexpr static char B='a';",
			"    using Arr=array<int, A>;",
			"    struct Endpos {",
			"        int link,len;",
			"        Arr ch;",
			"    };",
			"    vector<Endpos> edp;",
			"",
			"    void init() { edp.clear(),edp.push_back({-1}); }",
			"    int new_edp() { edp.push_back({}); return edp.size()-1; }",
			"",
			"    int split(int p,int c,int len) {",
			"        int q=edp[p].ch[c];",
			"        if(edp[q].len==len) return q;",
			"        else {",
			"            int clone=new_edp();",
			"            edp[clone]=edp[q];",
			"            edp[clone].len=len;",
			"            edp[q].link=clone;",
			"            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
			"                edp[p].ch[c]=clone;",
			"            return clone;",
			"        }",
			"    }",
			"",
			"    void extend(int p,int c) {",
			"        int cur=edp[p].ch[c];",
			"        edp[cur].len=edp[p].len+1;",
			"        for(;p!=-1&&(edp[p].ch[c]==cur||!edp[p].ch[c]);p=edp[p].link)",
			"            edp[p].ch[c]=cur;",
			"        if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
			"    }",
			"",
			"    void insert(string &s) {",
			"        int t=0,c=0;",
			"        for(auto x:s) {",
			"            c=x-B;",
			"            if(!edp[t].ch[c]) edp[t].ch[c]=new_edp();",
			"            t=edp[t].ch[c];",
			"        }",
			"    }",
			"",
			"    void build() {",
			"        queue<int> q;",
			"        q.push(0);",
			"        while(q.size()) {",
			"            int p=q.front();",
			"            q.pop();",
			"            for(int c=0;c<A;c++) if(edp[p].ch[c]) ",
			"                extend(p, c),q.push(edp[p].ch[c]);",
			"        }",
			"    }",
			"",
			"    int size() { return edp.size(); }",
			"    void clear() { init(); }",
			"    ",
			"    GeneralSuffixAutomaton() { init(); }",
			"    GeneralSuffixAutomaton(int sz) { edp.reserve(sz),init(); }",
			"} sam;",
		],
		"description": "General Suffix Automaton (offline version, without trie)",
	},	

	"Palindrome Automaton": {
		"prefix": "#pam",
		"body": [
			"struct PalindromeAutomaton {",
			"    const static int A=26;",
			"    const static char B='a';",
			"    struct Node {",
			"        int len,link;",
			"        int cnt;",
			"        int ch[A];",
			"    };",
			"    vector<Node> node;",
			"    string str;",
			"    int last;",
			"",
			"    int new_node(int len) {",
			"        node.push_back({len});",
			"        return node.size()-1;",
			"    }",
			"    ",
			"    void clear() {",
			"        node.clear();",
			"        last=0;",
			"        str=\"!\";",
			"        new_node(0);",
			"        new_node(-1);",
			"        node[0].link=1;",
			"    }",
			"",
			"    int getfail(int x) {",
			"        while(str[str.size()-node[x].len-2]!=str.back()) x=node[x].link;",
			"        return x;",
			"    }",
			"",
			"    void extend(char x) {",
			"        str.push_back(x);",
			"        int c=x-B;",
			"        int pre=getfail(last);",
			"        if(!node[pre].ch[c]) {",
			"            int cur=new_node(node[pre].len+2);",
			"            node[cur].link=node[getfail(node[pre].link)].ch[c];",
			"            node[pre].ch[c]=cur;",
			"        }",
			"        last=node[pre].ch[c];",
			"        node[last].cnt++;",
			"    }",
			"",
			"    void build(string &s) { for(auto x:s) extend(x); }",
			"    int size() { return node.size(); }",
			"",
			"    PalindromeAutomaton() { clear(); }",
			"    PalindromeAutomaton(int sz) { str.reserve(sz),node.reserve(sz),clear(); }",
			"} pam;",
		],
		"description": "Palindrome Automaton",
	},

	"Double End Palindrome Automaton": {
		"prefix": "#depam",
		"body": [
			"struct PalindromeAutomaton {",
			"    const static int A=26;",
			"    const static char B='a';",
			"    struct Node {",
			"        int len,link;",
			"        int cnt;",
			"        int ch[A];",
			"    };",
			"    vector<Node> node;",
			"    deque<char> str;",
			"    int last_l,last_r;",
			"",
			"    int new_node(int len) {",
			"        node.push_back({len});",
			"        return node.size()-1;",
			"    }",
			"    ",
			"    void clear() {",
			"        node.clear();",
			"        last_l=last_r=0;",
			"        str.clear();",
			"        new_node(0);",
			"        new_node(-1);",
			"        node[0].link=1;",
			"    }",
			"",
			"    template<typename T> void extend(char x,int &last,T getfail) {",
			"        int c=x-B;",
			"        int pre=getfail(last);",
			"        if(!node[pre].ch[c]) {",
			"            int cur=new_node(node[pre].len+2);",
			"            node[cur].link=node[getfail(node[pre].link)].ch[c];",
			"            node[pre].ch[c]=cur;",
			"        }",
			"        last=node[pre].ch[c];",
			"        if(node[last].len==str.size()) last_l=last_r=last;",
			"        node[last].cnt++;",
			"    }",
			"",
			"    void extend_l(char x) {",
			"        str.push_front(x);",
			"        extend(x, last_l, [&](int x) {",
			"            int n=int(str.size())-1;",
			"            while(node[x].len+1>n||str[node[x].len+1]!=str[0]) x=node[x].link;",
			"            return x;",
			"        });",
			"    }",
			"",
			"    void extend_r(char x) {",
			"        str.push_back(x);",
			"        extend(x, last_r, [&](int x) {",
			"            int n=int(str.size())-1;",
			"            while(n-node[x].len-1<0||str[n-node[x].len-1]!=str[n]) x=node[x].link;",
			"            return x;",
			"        });",
			"    }",
			"",
			"    int size() { return node.size(); }",
			"",
			"    PalindromeAutomaton() { clear(); }",
			"    PalindromeAutomaton(int sz) { node.reserve(sz),clear(); }",
			"} pam;",
		],
		"description": "Double End Palindrome Automaton",
	},	
	

	  //==============================//
	 //=======algorithm:math=========//
	//==============================//

	"combinatorial number": {
		"prefix": "#cmb",
		"body": [
			"const int N=${1:1e5+10};",
			"LL faet[N],infaet[N];",
			"",
			"LL qpow(LL a,LL b){",
			"    LL  res=1;",
			"    while(b){",
			"        if(b&1) res=res*a%mod;",
			"        b>>=1;",
			"        a=a*a%mod;",
			"    }",
			"    return res;",
			"}",
			"",
			"void init(){",
			"    faet[1]=1,faet[0]=1;",
			"    infaet[1]=1,infaet[0]=1;",
			"    for(int i=2;i<N;i++){",
			"        faet[i]=faet[i-1]*i%mod;",
			"        infaet[i]=infaet[i-1]*qpow(i,mod-2)%mod;",
			"    }",
			"}",
			"",
			"LL get(int a,int b){",
			"    return faet[a]*infaet[a-b]%mod*infaet[b]%mod;",
			"}",
		],
		"description": "递推求组合数 O(n)",
	},

	"Prime factorization": {
		"prefix": "#prime_factorization",
		"body": [
			"const int M=1e5+10;",
			"bool st[M];",
			"int primes[M],minp[M],idx;",
			"",
			"void init(int n) {",
			"    st[1]=minp[1]=1;",
			"    for(int i=2;i<=n;i++) {",
			"        if(!st[i]) primes[idx++]=i,minp[i]=i;",
			"        for(int j=0;primes[j]<=n/i;j++) {",
			"            st[primes[j]*i]=true;",
			"            minp[primes[j]*i]=primes[j];",
			"            if(i%primes[j]==0) break;",
			"        }",
			"    }",
			"}",
			"",
			"void get(int val,map<int,int> &mp) {",
			"    while(val>1) {",
			"        int t=minp[val];",
			"        auto it=mp.emplace(t,1).first;",
			"        val/=t;",
			"        while(val%t==0) {",
			"            it->second++;",
			"            val/=t;",
			"        }",
			"    }",
			"}",
		],
		"description": "质因数分解 O(nlogn)",
	},	

	"Matrix": {
		"prefix": "#matrix",
		"body": [
			"template<typename T,int R,int C=R> struct Matrix {",
			"    array<array<T,C>,R> v;",
			"",
			"    template<int Rr,int Cr> Matrix<T,R,Cr> operator*(const Matrix<T,Rr,Cr> &r) {",
			"        static_assert(C==Rr,\"\");",
			"        array<array<T,Cr>,R> ans;",
			"        for(int i=0;i<R;i++) {",
			"            for(int j=0;j<C;j++) {",
			"                T res{};",
			"                for(int k=0;k<C;k++)",
			"                    res+=v[i][k]*r[k][j];",
			"                ans[i][j]=res;",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    Matrix operator+(const Matrix &r) {",
			"        array<array<T,C>,R> ans;",
			"        for(int i=0;i<R;i++) for(int j=0;j<C;j++) ans[i][j]=v[i][j]+r[i][j];",
			"        return ans;",
			"    }",
			"",
			"    Matrix operator-(const Matrix &r) {",
			"        array<array<T,C>,R> ans;",
			"        for(int i=0;i<R;i++) for(int j=0;j<C;j++) ans[i][j]=v[i][j]-r[i][j];",
			"        return ans;",
			"    }",
			"",
			"    Matrix &operator*=(const Matrix<T,C,C> &r) { return *this=*this*r; }",
			"    Matrix &operator+=(const Matrix &r) { return *this=*this+r; }",
			"    Matrix &operator-=(const Matrix &r) { return *this=*this-r; }",
			"",
			"    Matrix pow(long long k) {",
			"        Matrix res(1),x=*this;",
			"        while(k) { if(k&1) res*=x; k>>=1; x*=x; }",
			"        return res;",
			"    }",
			"",
			"    auto &operator[](int idx) { return v[idx]; }",
			"    auto &operator[](int idx) const { return v[idx]; }",
			"",
			"    void clear() { v={}; }",
			"    void unit(T x=1) { static_assert(R==C,\"\"); clear(); for(int i=0;i<R;i++) v[i][i]=x; }",
			"",
			"    Matrix() { clear(); }",
			"    Matrix(T x) { unit(x); }",
			"    Matrix(const array<array<T,C>,R> &x) { v=x; }",
			"}; using Mtrx=Matrix<int, 2>;",
		],
		"description": "Matrix",
	},	

	  //==============================//
	 //=======algorithm:graph========//
	//==============================//

	"LCA": {
		"prefix": "#lca",
		"body": [
			"constexpr int N=1e5+10,M=__lg(N);",
			"int fa[N][M+1],dep[N]={0,1};",
			"",
			"void get_lca(int u,int p) {",
			"    for(int v:adj[u]) {",
			"        if(v==p) continue;",
			"        dep[v]=dep[u]+1;",
			"        fa[v][0]=u;",
			"        for(int i=1;i<=M;i++)",
			"            fa[v][i]=fa[fa[v][i-1]][i-1];",
			"        get_lca(v,u);",
			"    }",
			"}",
			"",
			"int lca(int a,int b) {",
			"    if(dep[a]<dep[b]) swap(a,b);",
			"    for(int k=M;~k;k--)",
			"        if(dep[fa[a][k]]>=dep[b])",
			"            a=fa[a][k];",
			"    if(a==b) return a;",
			"    for(int k=M;~k;k--)",
			"        if(fa[a][k]!=fa[b][k])",
			"            a=fa[a][k],b=fa[b][k];",
			"    return fa[a][0];",
			"}",
		],
		"description": [
			"倍增求LCA O(nlogn)",
			"需要的头文件: <vector>",
			"",
			"变量: N=点数 | M=位数",
			"初始化: dep[root]=1;"
		],
	},

	  //==============================//
	 //=======algorithm:flow=========//
	//==============================//

	"maximum flow": {
		"prefix": "#dinic",
		"body": [
			"const int N=${1:1e4+10},M=${2:1e5+10},INF=0x3f3f3f3f;",
			"int e[M],ne[M],f[M],idx;",
			"int h[N],q[N],arc[N],d[N];",
			"int n,m,S,T;",
			"",
			"void add(int a,int b,int c){",
			"    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;",
			"    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;",
			"}",
			"",
			"int dfs(int id,int lim){",
			"    if(id==T) return lim;",
			"    int flow=0;",
			"    for(int i=arc[id];~i&&flow<lim;i=ne[i]){",
			"        int ver=e[i];",
			"        arc[id]=i;",
			"        if(f[i]&&d[ver]==d[id]+1){",
			"            int t=dfs(ver,min(f[i],lim-flow));",
			"            if(!t) d[ver]=-1;",
			"            f[i]-=t,f[i^1]+=t,flow+=t;",
			"        }",
			"    }",
			"    return flow;",
			"}",
			"",
			"bool bfs(){",
			"    memset(d,-1,sizeof d);",
			"    q[0]=S,arc[S]=h[S],d[S]=0;",
			"    int hh=0,tt=1;",
			"    while(hh<tt){",
			"        int ver=q[hh++];",
			"        for(int i=h[ver];~i;i=ne[i]){",
			"            int t=e[i];",
			"            if(f[i]&&d[t]==-1){",
			"                d[t]=d[ver]+1;",
			"                arc[t]=h[t];",
			"                if(t==T) return 1;",
			"                q[tt++]=t;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			"int dinic(){",
			"    int F=0,flow=0;",
			"    while(bfs()) while(flow=dfs(S,INF)) F+=flow;",
			"    return F;",
			"}",
		],
		"description": "Dinic maxflow",
	},

	"minimum cost maximum flow": {
		"prefix": "#mcmf",
		"body": [
			"const int N=${1:1e4+10},M=${2:1e5+10},INF=0x3f3f3f3f;",
			"int ne[M],e[M],f[M],w[M],idx;",
			"int h[N],q[N],d[N],pre[N],mf[N];",
			"int n,m,S,T;",
			"bool inq[N];",
			"",
			"void add(int a,int b,int c,int d){",
			"    e[idx]=b,f[idx]=c,w[idx]=d,ne[idx]=h[a],h[a]=idx++;",
			"    e[idx]=a,f[idx]=0,w[idx]=-d,ne[idx]=h[b],h[b]=idx++;",
			"}",
			"",
			"bool spfa(){",
			"    memset(d,0x3f,sizeof d);",
			"    memset(mf,0,sizeof mf);",
			"    int hh=0,tt=1;",
			"    q[0]=S,d[S]=0,mf[S]=INF;",
			"    while(hh!=tt){",
			"        int ver=q[hh++];",
			"        if(hh==N) hh=0;",
			"        inq[ver]=0;",
			"",
			"        for(int i=h[ver];~i;i=ne[i]){",
			"            int t=e[i];",
			"            if(f[i]&&d[t]>d[ver]+w[i]){",
			"                d[t]=d[ver]+w[i];",
			"                pre[t]=i;",
			"                mf[t]=min(mf[ver],f[i]);",
			"                if(!inq[t]){",
			"                    q[tt++]=t;",
			"                    if(tt==N) tt=0;",
			"                    inq[t]=1;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return mf[T]>0;",
			"}",
			"",
			"void EK(int &flow,int &cost){",
			"    flow=cost=0;",
			"    while(spfa()){",
			"        flow+=mf[T],cost+=mf[T]*d[T];",
			"        for(int i=T;i!=S;i=e[pre[i]^1]){",
			"            f[pre[i]]-=mf[T];",
			"            f[pre[i]^1]+=mf[T];",
			"        }",
			"    }",
			"}",
		],
		"description": "EK minimum cost maximum flow",
	},

	  //==============================//
	 //========algorithm:dp==========//
	//==============================//

	"Convex Hull Trick": {
		"prefix": "#convex_hull_trick",
		"body": [
			"LL dp(int n) {",
			"    LL res=0,pre=0;",
			"    vector<pair<LL,LL>> q(1);",
			"    for(int i=1,idx=0;i<=n;i++) {",
			"        ",
			"        // assert(idx<q.size());",
			"        auto [x,y]=q[idx];",
			"        LL k=0.0;",
			"        LL b=y-k*x;",
			"        while(idx+1<q.size()) {",
			"            auto [x,y]=q[idx+1];",
			"            if(y-k*x<=b) {",
			"                b=y-k*x;",
			"                idx++;",
			"            }",
			"            else break;",
			"        }",
			"        ",
			"        res=0.0;",
			"        x=0.0;",
			"        y=0.0;",
			"    ",
			"        while(q.size()>=2) {",
			"            auto [xl,yl]=q[q.size()-2];",
			"            auto [xr,yr]=q[q.size()-1];",
			"            if((y-yr)*(x-xl)<=(y-yl)*(x-xr)) q.pop_back();",
			"            else break;",
			"        }",
			"        q.emplace_back(x,y);",
			"    }",
			"    return res;",
			"}",
		],
		"description": "Convex Hull Trick",
	},
	
}